---
title: 2DFAの実装をした
---

# やったこと

## 2DFAの勉強をした

双方向決定的有限状態オートマトン(2DFA)がどうしてDFAに変換できるのかよく分からなかったので勉強した。

末尾が文字`a`である文字列`wa`があるときに、`a`の位置に状態`q`で入ってきて、`w`の文字列を戻ったりしたあと`a`の次の位置へ`p`で出て行くような状況を`T[wa](q) = p`と書くことにする。（下図参照）

```
| ... w ... | a |
 /-<-------<-[ ]<-q-
 \->------->-[ ]-p->
```

状態の数は有限だから、`T[wa](q) = p`の組み合わせの数は状態の数を`n`としてたかだか`n^n`の有限個になる。これは明かに文字列の数よりも小さいので、異なる文字列`x`と`y`で`T[x] = T[y]`となるような`x, y`の組が存在する（鳩の巣原理）。このような`x, y`に同じ末尾文字列`z`をつけた文字列`xz, yz`は`xz`が受理されるときに限り`yz`も受理されるだろう。逆もまた然り。よって`T[x] = T[y]`であることを`x ~ y`とすると`~`は同値関係であり、Myhill-Nerodeの定理より2DFAは正規であると言える。そして、`T[x]`を状態としてDFAを構築することができる、というわけ。

しかしこれを実装するのはとてもしんどい。あと、Verdiという人が考えた別のDFA構築の方法もあって、そっちも面白い。が、やはり実装が面倒。

## 実装した

なぜかHaskell。

https://github.com/MakeNowJust-Labo/two-way-dfa

DFAへの変換を実装していないのでダメと言えばダメ。
