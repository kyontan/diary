---
title: 配列のrotateについて
---

# やったこと

ジャンクガレッジで辛ラーメンを食べた。やはり辛いものは苦手だ（昨日財布を忘れた腹いせ）

## 配列のrotateについて

長さ`N`の配列を`D`個分rotateするには、いくつか方法がある。

1. 一時配列を使う方法

  `D`個分の要素を先頭からコピーして、配列の残りの要素を先頭まで持ってきたあとコピーしたものをその後ろに追加する方法。一番直感的。
  `N - D < D`の際に`N - D`個分後ろからコピーするようにしたりすると、`D`が極端に小さい/大きい場合は十分に早いのだけど`D`が`N / 2`に近付くとかなり遅くなる。
  あとin-placeじゃない。

2. ジャグリング法

  `D = 1`の場合、`0`番目の要素を保存しておいて、`1`番目の要素を`0`番目に移動して、`2`番目を`1`番目に移動して、を`N - 2`番目の要素まで繰り返し`N - 1`番目に保存しておいた`0`番目の要素を移動すれば完了する。
  しかし`D >= 2`の場合、同じようにしようとすると、保存しておかなきゃいけない先頭の要素の数が`D`個になってしまい、in-placeにならない。そこで`(i + D) % N`番目の要素を`i % D`番目に代入したら、次は`(i + 2 *D) % N`番目の要素を`(i + D) % N`番目の要素に代入し、最初の位置の手前に戻ってきたら保存しておいた最初の要素を代入する、という風にする。すると`D`と`N`がもし互いに素なら一周すると開始位置が`1`ずれて、何周か繰り返すうちに最初の位置に戻ってくるようになり、完了する。`D`と`N`が互いに素でないなら最大公約数だけ系列が存在するので、開始位置をずらして全ての系列に対して同じことをしていけばいい。
  こうすることで、in-placeで内側のループの回数は`N - GCD(N, D)`回で動く。`GCD(N, D)`が大きくなるとき（例えば`N`が2の倍数のときの`D = N / 2`のとき）に群を抜いて高速になるが、それ以外のときは全体的に遅めな気がする（ランダムアクセスすぎてキャッシュに載らない？）。

3. ブロックスワップ、リバース

  明日解説する。眠い。

とりあえず、ブロックスワップが優秀な気がするのでこれで行きたい。

重要なことは、`rotate`は使われるとしたら`D = 1`か`D = -1`で少しずつ回転させていくか、もしくは様々な大きさで満遍なく回転させるかのどちらかだと予想できて、現状の実装は様々な大きさの場合にパーフォーマンスがそこまでよくなくて、また`|D| = 1`の場合もそれならメモリ確保は不要なのだということ。個人的にはどうにかしてin-placeでいいという流れにしたい。少なくともRubyはin-placeだった。
